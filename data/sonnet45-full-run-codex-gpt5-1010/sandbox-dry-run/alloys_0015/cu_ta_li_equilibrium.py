#!/usr/bin/env python3
"""
Equilibrium phase analysis for Cu–Ta–Li at Cu:Ta:Li = 2:6:1 (at. ratio)

Follows CALPHAD.md best practices:
- Use only the local TDB in TnETDBDB (absolute path).
- Read CALPHAD guidance once; cache the path info in code.
- One script: load DB → set conditions → solve → summarize → write JSON/CSV.
- Fix DOF and fractions once; compute phase fractions from NP.

Outputs:
- results.json: structured results including phase fractions at 298, 500, 800, 1000 K
- results.csv: flat table of (T, Phase, Fraction)

Author: Auto-generated by Codex CLI agent
"""
from __future__ import annotations

import json
from pathlib import Path
from typing import Dict, List

import numpy as np

from pycalphad import Database, equilibrium, variables as v  # type: ignore


def main() -> None:
    # --- Cached minimal info from CALPHAD.md (read once elsewhere) ---
    # Local TDBs reside under the repo root in a folder named 'TnETDBDB'.
    TDB_PATH = Path('/Users/delip/play/miniclaimspy/TnETDBDB/cost507R.TDB')

    if not TDB_PATH.exists():
        raise SystemExit(
            f"Required local TDB not found at {TDB_PATH}. Per CALPHAD.md, no external TDBs allowed."
        )

    # Components and composition (atomic ratio 2:6:1 → X(CU)=2/9, X(TA)=6/9, X(LI)=1/9)
    comps = ['CU', 'TA', 'LI', 'VA']
    x_cu = 2.0 / 9.0
    x_ta = 6.0 / 9.0
    # X(LI) is implied as 1 - x_cu - x_ta

    # Temperatures (K)
    temperatures = [298.0, 500.0, 800.0, 1000.0]

    # Load database
    dbf = Database(str(TDB_PATH))

    # Quick sanity: ensure required elements are available
    needed = {'CU', 'TA', 'LI'}
    available = set(dbf.elements)
    if not needed.issubset(available):
        payload = {
            'tdb_path': str(TDB_PATH),
            'available_elements': sorted(list(available)),
            'required_elements': sorted(list(needed)),
            'message': (
                'Selected TDB does not cover the required element set; cannot compute '
                'Cu–Ta–Li equilibria per CALPHAD.md (local DB only).'
            ),
        }
        Path('results.json').write_text(json.dumps(payload, indent=2))
        print(payload['message'])
        return

    # Build a phase list: include phases that have any of the required elements.
    def phase_has_any(dbf: Database, phase: str, elems: List[str]) -> bool:
        const = dbf.phases[phase].constituents
        flat = {str(c).upper() for subl in const for c in subl}
        return bool(flat & {e.upper() for e in elems})

    candidate_phases = sorted(
        p for p in dbf.phases.keys() if phase_has_any(dbf, p, ['CU', 'TA', 'LI'])
    )
    assert candidate_phases, 'No phases selected; did you build the phases list?'

    # Conditions: N−1 mole fraction constraints for a ternary system
    conds = {
        v.T: np.array(temperatures),
        v.P: 101325.0,
        v.N: 1.0,
        v.X('CU'): x_cu,
        v.X('TA'): x_ta,
    }

    # Compute equilibrium
    # Compute full equilibrium dataset for robustness
    eq = equilibrium(dbf, comps, candidate_phases, conds)

    # Debug-friendly guardrails: ensure NP exists and has per-phase data
    if 'NP' not in eq.data_vars:
        raise RuntimeError("Equilibrium dataset lacks 'NP' variable; cannot compute phase fractions.")

    # Robust per-phase fractions via masking NP with Phase labels and summing over 'vertex'.
    phase_labels = eq['Phase']  # includes 'vertex' in dims
    all_phase_names = sorted({str(p) for p in np.unique(phase_labels.values)})
    if not all_phase_names:
        raise RuntimeError('No phase labels found in equilibrium result.')

    total_moles = eq['NP']  # dims may or may not include 'vertex'
    per_phase_moles = []
    from xarray import concat as xr_concat
    for ph in all_phase_names:
        np_ph = total_moles.where(phase_labels == ph)
        if 'vertex' in np_ph.dims:
            np_ph = np_ph.sum('vertex')
        per_phase_moles.append(np_ph.expand_dims({'phase': [ph]}))
    pf = xr_concat(per_phase_moles, dim='phase')

    # Total moles per condition (sum over phases via equality NP=sum over vertices already)
    total_no_vtx = total_moles
    if 'vertex' in total_no_vtx.dims:
        total_no_vtx = total_no_vtx.sum('vertex')
    phase_frac = pf / total_no_vtx

    # Build per-temperature fraction mapping
    # Squeeze out singleton dims while preserving 'phase' and 'T'
    # Note: X variables are fixed scalars; they may remain as coords.
    results: Dict[str, Dict[str, float]] = {}
    stable: Dict[str, List[str]] = {}

    # Ensure 'T' is a coordinate we can iterate over
    Ts = phase_frac['T'].values.tolist()
    phases = [str(p) for p in phase_frac['phase'].values.tolist()]

    for Ti in Ts:
        sel = phase_frac.sel(T=Ti)
        # If other dims remain (e.g., P, X_...), reduce by taking the scalar value
        for dim in list(sel.dims):
            if dim not in {'phase'}:
                sel = sel.squeeze(dim)

        # Convert to {phase: fraction}
        frac_by_phase = {str(ph): float(sel.sel({'phase': ph}).values) for ph in phases}
        # Numerical cleanup: set very small negatives to zero
        for k, vval in list(frac_by_phase.items()):
            if abs(vval) < 1e-10:
                frac_by_phase[k] = 0.0

        # Stable phases threshold
        stable_ph = [p for p, val in frac_by_phase.items() if val > 1e-3]
        # Sort for readability
        frac_sorted = dict(sorted(frac_by_phase.items(), key=lambda kv: kv[1], reverse=True))

        results[f"{Ti:.1f}"] = frac_sorted
        stable[f"{Ti:.1f}"] = stable_ph

    # Write outputs
    out_json = {
        'tdb_path': str(TDB_PATH),
        'components': comps,
        'composition': {'X(CU)': x_cu, 'X(TA)': x_ta, 'X(LI)': 1.0 - x_cu - x_ta},
        'temperatures_K': temperatures,
        'phases_considered': candidate_phases,
        'phase_fractions': results,
        'stable_phases_threshold_1e-3': stable,
        'notes': 'Fractions are per total moles; threshold = 1e-3 for stability listing.',
    }
    Path('results.json').write_text(json.dumps(out_json, indent=2))

    # CSV: Temperature,Phase,Fraction
    with open('results.csv', 'w') as f:
        f.write('Temperature_K,Phase,Fraction\n')
        for Tstr, mapping in results.items():
            for ph, val in mapping.items():
                f.write(f"{Tstr},{ph},{val:.8f}\n")

    # Human-readable summary
    print('Database:', TDB_PATH)
    print('Components:', ', '.join(comps))
    print('Composition (mole fractions): X(CU)={:.6f}, X(TA)={:.6f}, X(LI)={:.6f}'.format(
        x_cu, x_ta, 1.0 - x_cu - x_ta
    ))
    for Tstr in [f"{t:.1f}" for t in temperatures]:
        mapping = results[Tstr]
        st = stable[Tstr]
        # Show only phases with > 1e-4 for readability
        shown = [(p, v) for p, v in mapping.items() if v > 1e-4]
        print(f"\nT = {Tstr} K:")
        if not shown:
            print('  No stable condensed phases (all fractions < 1e-4).')
        else:
            for p, vval in shown:
                print(f"  {p:20s}  {vval: .6f}")
        print(f"  Stable phases (>1e-3): {', '.join(st) if st else '(none)'}")


if __name__ == '__main__':
    main()
